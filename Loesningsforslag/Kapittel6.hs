module Kapittel6 where

-- ======================== ⭐ Exercise 1 ⭐ ========================

-- fac er i utgangspunktet definert slik i boka (s. 59). Dersom man
-- kaller på fac med et negativt tall vil funksjonen aldri terminere.
-- Vi starter med -1 og trekker fra 1 hver gang og vil dermed aldri
-- treffe "base casen" som terminerer rekursjonen.
-- -------------------------------------------------------------------
fac :: Int -> Int
fac 0 = 1
fac n = n * fac (n - 1)
-- -------------------------------------------------------------------

-- Sier i stedet at base casen treffer for alle tall mindre enn eller
-- lik 0.
-- -------------------------------------------------------------------
fac' :: Int -> Int
fac' n
    | n <= 0    = 1
    | otherwise = n * fac' (n - 1)
-- -------------------------------------------------------------------

-- ======================== ⭐ Exercise 2 ⭐ ========================

-- -------------------------------------------------------------------
sumdown :: Int -> Int
sumdown 0 = 0
sumdown n = n + sumdown (n - 1)
-- -------------------------------------------------------------------

-- ======================== ⭐ Exercise 3 ⭐ ========================

-- -------------------------------------------------------------------
(^*) :: Int -> Int -> Int
m ^* 0 = 1
m ^* n = m * (m ^* (n - 1))
-- -------------------------------------------------------------------

-- ======================== ⭐ Exercise 4 ⭐ ========================

-- -------------------------------------------------------------------
euclid :: Int -> Int -> Int
euclid x y
    | x == y = x
    | x <  y = euclid  x     (y - x)
    | y <  x = euclid (x - y) y
-- -------------------------------------------------------------------

-- ======================== ⭐ Exercise 5 ⭐ ========================

-- length [1, 2, 3]
-- -------------------------------------------------------------------

length' :: [a] -> Int
length' []     = 0
length' (x:xs) = 1 + length' xs

{-
      length [1, 2, 3]
    = 1 ++ length [2, 3]
    = 1 ++ (1 ++ length [3])
    = 1 ++ (1 ++ (1 ++ length []))
    = 1 ++ (1 ++ (1 ++ 0))
    = 3
-}

-- -------------------------------------------------------------------

-- drop 3 [1, 2, 3]
-- -------------------------------------------------------------------

drop' :: Int -> [a] -> [a]
drop' 0  xs    = xs
drop' _  []    = []
drop' n (_:xs) = drop' (n-1) xs

{-
      drop 3 [1, 2, 3]
    = drop 2 [2, 3]
    = drop 1 [3]
    = drop []
    = []
-}

-- -------------------------------------------------------------------

-- init [1, 2, 3]
-- -------------------------------------------------------------------

init' :: [a] -> [a]
init' [_]    = []
init' (x:xs) = x : init xs

{-
    init [1, 2, 3]
    = 1 : (init [2, 3])
    = 1 : 2 : (init [3])
    = 1 : 2 : []
    = [1, 2]
-}

-- -------------------------------------------------------------------

-- ======================== ⭐ Exercise 6 ⭐ ========================

-- a
-- -------------------------------------------------------------------
and' :: [Bool] -> Bool
and' []     = True
and' (b:bs) = b && and' bs 
-- -------------------------------------------------------------------

-- b
-- -------------------------------------------------------------------
concat' :: [[a]] -> [a]
concat' []     = []
concat' (x:xs) = x ++ concat' xs
-- -------------------------------------------------------------------

-- c
-- -------------------------------------------------------------------
replicate' :: Int -> a -> [a]
replicate' 0 _ = []
replicate' n x = x : replicate' (n - 1) x
-- -------------------------------------------------------------------

-- d
-- -------------------------------------------------------------------
(!!!) :: [a] -> Int -> a
(x:_ ) !!! 0 = x
(_:xs) !!! n = xs !!! (n - 1)
-- -------------------------------------------------------------------

-- e
-- -------------------------------------------------------------------
elem' :: Eq a => a -> [a] -> Bool
elem' x []     = False
elem' x (y:ys)
    | x == y    = True
    | otherwise = elem' x ys
-- -------------------------------------------------------------------

-- ======================== ⭐ Exercise 7 ⭐ ========================

-- -------------------------------------------------------------------
merge [] ys = ys
merge xs ys = xs
merge (x:xs) (y:ys) = if   x <= y
                      then x : merge xs (y : ys)
                      else y : merge    (x : xs) ys
-- -------------------------------------------------------------------

-- ======================== ⭐ Exercise 8 ⭐ ========================

-- -------------------------------------------------------------------
halve' xs = splitAt (length xs `div` 2) xs

msort :: Ord a => [a] -> [a]
msort [ ] = [ ]
msort [x] = [x]
msort xs  = merge (msort ys) (msort zs)
    where (ys, zs) = halve' xs
-- -------------------------------------------------------------------

-- ======================== ⭐ Exercise 9 ⭐ ========================

-- a
-- -------------------------------------------------------------------
sum' :: [Int] -> Int
sum' []     = 0
sum' (x:xs) = x + sum' xs
-- -------------------------------------------------------------------

-- b
-- -------------------------------------------------------------------
take' :: Int -> [a] -> [a]
take' 0  _     = []
take' n (x:xs) = x : take' (n - 1) xs
-- -------------------------------------------------------------------

-- c
-- -------------------------------------------------------------------
last' :: [a] -> a
last' [x]    = x
last' (_:xs) = last' xs
-- -------------------------------------------------------------------